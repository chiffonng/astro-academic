---
import type { MarkdownHeading } from "astro"

import { getHeadingMargin } from "@/lib/toc-utils"
import { cn } from "@/lib/utils"
import Icon from "@/components/base/Icon.astro"
import TOCHeadingLink from "@/components/blog/TOCHeadingLink.astro"
import { ScrollArea } from "@/components/ui/scroll-area"

interface Props {
  headings: MarkdownHeading[]
}

const { headings } = Astro.props
const hasHeadings = headings && headings.length > 0
---

{
  hasHeadings && (
    <nav
      id="mobile-toc-container"
      class="w-full xl:hidden"
      role="navigation"
      aria-label="Table of contents"
    >
      <details class="group" role="button" aria-expanded="false">
        <summary class="focus-visible:ring-ring flex w-full cursor-pointer items-center justify-between focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:outline-none">
          <header class="mx-auto flex w-full max-w-3xl items-center justify-between px-4 py-3">
            <div class="flex items-center gap-3">
              <div
                class="relative flex size-5 flex-shrink-0 items-center justify-center"
                role="img"
                aria-label="Reading progress indicator"
              >
                <svg class="h-5 w-5" viewBox="0 0 24 24" aria-hidden="true">
                  <circle
                    class="text-primary/20"
                    cx="12"
                    cy="12"
                    r="10"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                  />
                  <circle
                    id="mobile-toc-progress-circle"
                    class="text-primary"
                    cx="12"
                    cy="12"
                    r="10"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-dasharray="62.83"
                    stroke-dashoffset="62.83"
                    transform="rotate(-90 12 12)"
                  />
                </svg>
              </div>
              <div class="flex flex-col gap-1">
                <span
                  id="mobile-toc-current-section"
                  class="text-foreground truncate text-sm leading-tight font-medium"
                >
                  Overview
                </span>
              </div>
            </div>
            <Icon
              name="mingcute:down-line"
              class="text-muted-foreground size-4 flex-shrink-0 transition-transform duration-200 group-open:rotate-180"
              aria-hidden="true"
            />
          </header>
        </summary>

        <ScrollArea
          client:load
          className="mx-auto max-w-3xl border-t border-border/50"
          data-toc-header-scroll
        >
          <div class="max-h-[35vh]">
            <nav aria-labelledby="mobile-toc-heading">
              <h3 id="mobile-toc-heading" class="sr-only">
                Table of Contents
              </h3>
              <ul
                class="flex list-none flex-col gap-y-1 px-3 py-2"
                id="mobile-table-of-contents"
                role="list"
              >
                {headings.map((heading) => (
                  <li
                    role="listitem"
                    class={cn("transition-colors", getHeadingMargin(heading.depth))}
                  >
                    <TOCHeadingLink heading={heading} href={`#${heading.slug}`} variant="mobile" />
                  </li>
                ))}
              </ul>
            </nav>
          </div>
        </ScrollArea>
      </details>
    </nav>
  )
}

<script>
  import { BaseTOCController } from "@/lib/toc-scroll"

  const INITIAL_OVERVIEW_TEXT = "Overview"
  const PROGRESS_CIRCLE_RADIUS = 10
  const PROGRESS_CIRCLE_CIRCUMFERENCE = 2 * Math.PI * PROGRESS_CIRCLE_RADIUS

  class MobileTOCController extends BaseTOCController {
    private progressCircle: SVGCircleElement | null = null
    private currentSectionText: HTMLElement | null = null
    private detailsElement: HTMLDetailsElement | null = null
    private progressScrollHandler: (() => void) | null = null

    // Required abstract methods
    getContainerSelector() {
      return "#mobile-toc-container"
    }

    getScrollAreaSelector() {
      return "[data-radix-scroll-area-viewport]"
    }

    getContainerAttribute() {
      return "data-toc-header-scroll"
    }

    getLinkSelector() {
      return "#mobile-toc-container .mobile-toc-item"
    }

    getMaskClasses() {
      return { top: "mask-t-from-80%", bottom: "mask-b-from-80%" }
    }

    init() {
      this.setupMobileElements()
      super.init() // Use BaseTOCController's init
      this.setupMobileInteraction()
      this.setupProgressHandler()
      this.updateProgress()
      this.updateCurrentSection()
    }

    private setupMobileElements() {
      this.progressCircle = document.querySelector(
        "#mobile-toc-progress-circle"
      ) as SVGCircleElement | null
      this.currentSectionText = document.getElementById("mobile-toc-current-section")
      this.detailsElement = document.querySelector("#mobile-toc-container details")

      // Initialize progress circle
      if (this.progressCircle) {
        this.progressCircle.style.strokeDasharray = PROGRESS_CIRCLE_CIRCUMFERENCE.toString()
        this.progressCircle.style.strokeDashoffset = PROGRESS_CIRCLE_CIRCUMFERENCE.toString()
      }
    }

    private setupProgressHandler() {
      this.progressScrollHandler = () => {
        this.updateProgress()
        this.updateCurrentSection()
      }
      window.addEventListener("scroll", this.progressScrollHandler, { passive: true })
    }

    private setupMobileInteraction() {
      const listElement = document.getElementById("mobile-table-of-contents")
      if (listElement) {
        listElement.querySelectorAll(".mobile-toc-item").forEach((item) => {
          item.addEventListener("click", () => {
            if (this.detailsElement) this.detailsElement.open = false
          })
        })
      }

      if (this.detailsElement) {
        this.detailsElement.addEventListener("toggle", () => {
          if (this.detailsElement?.open) {
            setTimeout(() => {
              const maskClasses = this.getMaskClasses()
              this.tocScrollMask.update(maskClasses)
            }, 100)
          }
        })
      }
    }

    private updateCurrentSection() {
      if (!this.currentSectionText || this.state.headings.length === 0) {
        if (this.currentSectionText) {
          this.currentSectionText.textContent = INITIAL_OVERVIEW_TEXT
        }
        return
      }

      let currentText = INITIAL_OVERVIEW_TEXT

      if (this.state.activeIds.length > 0) {
        const activeTexts = this.state.headings
          .filter((heading) => this.state.activeIds.includes(heading.id) && heading.textContent)
          .map((heading) => heading.textContent!.trim())

        if (activeTexts.length > 0) {
          currentText = activeTexts.join(", ")
        }
      }

      this.currentSectionText.textContent = currentText
    }

    private updateProgress() {
      if (!this.progressCircle) return

      const scrollTop = window.scrollY
      const documentHeight = document.documentElement.scrollHeight
      const windowHeight = window.innerHeight
      const scrollableDistance = documentHeight - windowHeight

      const scrollProgress =
        scrollableDistance > 0 ? Math.min(Math.max(scrollTop / scrollableDistance, 0), 1) : 0

      const offset = PROGRESS_CIRCLE_CIRCUMFERENCE * (1 - scrollProgress)
      this.progressCircle.style.strokeDashoffset = offset.toString()
    }

    protected setupCustomBehavior() {
      // Override base scroll handler to include progress and section updates
      const originalScrollHandler = this.scrollHandler
      this.scrollHandler = () => {
        if (originalScrollHandler) originalScrollHandler()
        this.updateProgress()
        this.updateCurrentSection()
      }
    }

    cleanup() {
      if (this.progressScrollHandler) {
        window.removeEventListener("scroll", this.progressScrollHandler)
        this.progressScrollHandler = null
      }
      super.cleanup()
    }
  }

  const controller = new MobileTOCController()

  document.addEventListener("astro:page-load", () => controller.init())
  document.addEventListener("astro:after-swap", () => {
    controller.cleanup()
    controller.init()
  })
  document.addEventListener("astro:before-swap", () => controller.cleanup())
</script>
