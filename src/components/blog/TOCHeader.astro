---
import type { MarkdownHeading } from "astro"

import { getHeadingMargin } from "@/lib/toc-utils"
import { cn } from "@/lib/utils"
import Icon from "@/components/base/Icon.astro"
import { ScrollArea } from "@/components/ui/scroll-area"

type Props = {
  headings: MarkdownHeading[]
}

const { headings } = Astro.props
---

{
  headings && headings.length > 0 && (
    <div id="mobile-toc-container" class="w-full xl:hidden">
      <details class="group">
        <summary class="flex w-full cursor-pointer items-center justify-between">
          <div class="mx-auto flex w-full max-w-3xl items-center justify-between px-4 py-3">
            <div class="flex items-center gap-2">
              <div class="relative flex size-4 flex-shrink-0 items-center justify-center">
                <svg class="h-4 w-4" viewBox="0 0 24 24">
                  <circle
                    class="text-primary/20"
                    cx="12"
                    cy="12"
                    r="10"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                  />
                  <circle
                    id="mobile-toc-progress-circle"
                    class="text-primary"
                    cx="12"
                    cy="12"
                    r="10"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-dasharray="62.83"
                    stroke-dashoffset="62.83"
                    transform="rotate(-90 12 12)"
                  />
                </svg>
              </div>
              <span
                id="mobile-toc-current-section"
                class="text-muted-foreground truncate text-sm leading-4"
              >
                Overview
              </span>
            </div>
            <Icon
              name="mingcute:down-line"
              class="text-muted-foreground size-4 flex-shrink-0 transition-transform duration-200 group-open:rotate-180"
            />
          </div>
        </summary>

        <ScrollArea client:load className="mx-auto max-w-3xl" data-toc-header-scroll>
          <div class="max-h-[30vh]">
            <ul class="flex list-none flex-col gap-y-2 px-4 pb-4" id="mobile-table-of-contents">
              {headings.map((heading) => (
                <li
                  class={cn("px-4 text-sm", getHeadingMargin(heading.depth), "text-foreground/60")}
                >
                  <a
                    href={`#${heading.slug}`}
                    class="mobile-toc-item underline decoration-transparent underline-offset-[3px] transition-colors duration-200 hover:decoration-inherit"
                    data-heading-id={heading.slug}
                  >
                    {heading.text}
                  </a>
                </li>
              ))}
            </ul>
          </div>
        </ScrollArea>
      </details>
    </div>
  )
}

<script>
  import { BaseTOCController } from "@/lib/toc-scroll"

  const INITIAL_OVERVIEW_TEXT = "Overview"
  const PROGRESS_CIRCLE_RADIUS = 10
  const PROGRESS_CIRCLE_CIRCUMFERENCE = 2 * Math.PI * PROGRESS_CIRCLE_RADIUS

  class MobileTOCController extends BaseTOCController {
    private progressCircle: SVGCircleElement | null = null
    private currentSectionText: HTMLElement | null = null
    private detailsElement: HTMLDetailsElement | null = null
    private progressScrollHandler: (() => void) | null = null

    // Required abstract methods
    getContainerSelector() {
      return "#mobile-toc-container"
    }

  class HeadingRegions {
    static build() {
      state.headings = Array.from(
        document.querySelectorAll<HTMLElement>(
          ".prose h2, .prose h3, .prose h4, .prose h5, .prose h6"
        )
      )

      if (state.headings.length === 0) {
        state.regions = []
        return
      }

      state.regions = state.headings.map((heading, index) => {
        const nextHeading = state.headings[index + 1]
        return {
          id: heading.id,
          start: heading.offsetTop,
          end: nextHeading ? nextHeading.offsetTop : document.body.scrollHeight
        }
      })
    }

    getContainerAttribute() {
      return "data-toc-header-scroll"
    }

    getLinkSelector() {
      return "#mobile-toc-container .mobile-toc-item"
    }

    getMaskClasses() {
      return { top: "mask-t-from-80%", bottom: "mask-b-from-80%" }
    }

    init() {
      this.setupMobileElements()
      super.init() // Use BaseTOCController's init
      this.setupMobileInteraction()
      this.setupProgressHandler()
      this.updateProgress()
      this.updateCurrentSection()
    }

    private setupMobileElements() {
      this.progressCircle = document.querySelector(
        "#mobile-toc-progress-circle"
      ) as SVGCircleElement | null
      this.currentSectionText = document.getElementById("mobile-toc-current-section")
      this.detailsElement = document.querySelector("#mobile-toc-container details")

        if (activeTexts.length > 0) {
          textToShow = activeTexts.join(", ")
        }
      }
    }

    private setupProgressHandler() {
      this.progressScrollHandler = () => {
        this.updateProgress()
        this.updateCurrentSection()
      }
      window.addEventListener("scroll", this.progressScrollHandler, { passive: true })
    }

    private setupMobileInteraction() {
      const listElement = document.getElementById("mobile-table-of-contents")
      if (listElement) {
        listElement.querySelectorAll(".mobile-toc-item").forEach((item) => {
          item.addEventListener("click", () => {
            if (this.detailsElement) this.detailsElement.open = false
          })
        })
      }

      if (this.detailsElement) {
        this.detailsElement.addEventListener("toggle", () => {
          if (this.detailsElement?.open) {
            setTimeout(() => {
              const maskClasses = this.getMaskClasses()
              this.tocScrollMask.update(maskClasses)
            }, 100)
          }
        })
      }
    }

  class ProgressCircle {
    static update() {
      if (!state.progressCircle) return

      const scrollableDistance = document.documentElement.scrollHeight - window.innerHeight
      const scrollProgress =
        scrollableDistance > 0 ? Math.min(Math.max(window.scrollY / scrollableDistance, 0), 1) : 0

      state.progressCircle.style.strokeDashoffset = (
        PROGRESS_CIRCLE_CIRCUMFERENCE *
        (1 - scrollProgress)
      ).toString()
    }
  }

  class MobileTOCController {
    static handleScroll() {
      const newActiveIds = HeadingRegions.getVisibleIds()

      if (JSON.stringify(newActiveIds) !== JSON.stringify(state.activeIds)) {
        state.activeIds = newActiveIds
        MobileTOCLinks.update(state.activeIds)
      }

      let currentText = INITIAL_OVERVIEW_TEXT

      if (this.state.activeIds.length > 0) {
        const activeTexts = this.state.headings
          .filter((heading) => this.state.activeIds.includes(heading.id) && heading.textContent)
          .map((heading) => heading.textContent!.trim())

        if (activeTexts.length > 0) {
          currentText = activeTexts.join(", ")
        }
      }

      this.currentSectionText.textContent = currentText
    }

    private updateProgress() {
      if (!this.progressCircle) return

      const scrollTop = window.scrollY
      const documentHeight = document.documentElement.scrollHeight
      const windowHeight = window.innerHeight
      const scrollableDistance = documentHeight - windowHeight

      const scrollProgress =
        scrollableDistance > 0 ? Math.min(Math.max(scrollTop / scrollableDistance, 0), 1) : 0

      const offset = PROGRESS_CIRCLE_CIRCUMFERENCE * (1 - scrollProgress)
      this.progressCircle.style.strokeDashoffset = offset.toString()
    }

    protected setupCustomBehavior() {
      // Override base scroll handler to include progress and section updates
      const originalScrollHandler = this.scrollHandler
      this.scrollHandler = () => {
        if (originalScrollHandler) originalScrollHandler()
        this.updateProgress()
        this.updateCurrentSection()
      }
    }

    cleanup() {
      if (this.progressScrollHandler) {
        window.removeEventListener("scroll", this.progressScrollHandler)
        this.progressScrollHandler = null
      }
      super.cleanup()
    }
  }

  const controller = new MobileTOCController()

  document.addEventListener("astro:page-load", () => controller.init())
  document.addEventListener("astro:after-swap", () => {
    controller.cleanup()
    controller.init()
  })
  document.addEventListener("astro:before-swap", () => controller.cleanup())
</script>
